{
  
    
        "post0": {
            "title": "Deploying web apps with Streamlit, Docker, and AWS - part 3",
            "content": "This is part 3 of 3. Make sure to read through part 1 and part 2 before you continue! . Introducing docker-compose . Suppose we want our users to be able to access some data like this . introduce this data and explain how it comes from my example! .   CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT PRICE . 0 | 0.00632 | 18 | 2.31 | 0 | 0.538 | 6.575 | 65.2 | 4.09 | 1 | 296 | 15.3 | 396.9 | 4.98 | 24 | . 1 | 0.02731 | 0 | 7.07 | 0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2 | 242 | 17.8 | 396.9 | 9.14 | 21.6 | . 2 | 0.02729 | 0 | 7.07 | 0 | 0.469 | 7.185 | 61.1 | 4.9671 | 2 | 242 | 17.8 | 392.83 | 4.03 | 34.7 | . 3 | 0.03237 | 0 | 2.18 | 0 | 0.458 | 6.998 | 45.8 | 6.0622 | 3 | 222 | 18.7 | 394.63 | 2.94 | 33.4 | . 4 | 0.06905 | 0 | 2.18 | 0 | 0.458 | 7.147 | 54.2 | 6.0622 | 3 | 222 | 18.7 | 396.9 | 5.33 | 36.2 | . but we don’t want to have to mess with csv’s .",
            "url": "https://collinprather.github.io/blog/docker/aws/2020/03/12/streamlit-docker-pt3.html",
            "relUrl": "/docker/aws/2020/03/12/streamlit-docker-pt3.html",
            "date": " • Mar 12, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Deploying web apps with Streamlit, Docker, and AWS - part 2",
            "content": "This is part 2 of 3. Make sure to read through part 1 first! . Deploying your web app to the cloud with AWS . Now, we will walk through how to deploy your web app to the cloud and make it publicly available! Just like in part 1, these instructions are tailored to my small example, but should generalize to any streamlit app you’ve built! . EC2 set-up . We’ll start by heading over to aws.amazon.com/console. If you do not yet have an account, create one! After you’re logged in, locate the Services tab in the upper left-hand corner, then select EC2. . . Next, you’ll want to use the tab on the left hand-side of the console to select Instances -&gt; Launch Instance. . include picture of choosing launch instance! . This will lead you to a screen prompting you to “Choose you an Amazon Machine Image”. There are many options to choose from here, but our life will be made simplest by choosing the Deep Learning AMI (Ubuntu 16.04) AMI. Using this image does introduce a bit of unneccessary overhead, however, it gurantees us that git and Docker will be pre-installed, so it will be our choice. . . After this, we will choose the type of instance to use. To ensure that we’ll have enough space to build and run our Docker image, it’s a safe (and cheap) bet to pick a t2.medium instance. . . . Your AWS account will be charged when you launch this instance. The good news is that you&#39;ll only be charged about $0.0464 per hour. Don&#39;t forget to terminate your instance when finished! From here, you can skip all the way to step 6 in launching the instance, which is where you’ll “Configure Security Group”. By default, all ports on our EC2 instance, other than 22, are closed to the public. In order to make our streamlit app publicly available, we need to open up port 8501. We can do so by creating a custom tcp rule, as pictured below. . . With that set, you can click “launch”. . Lastly, we will need to ssh into the instance to get the code to run our app in the cloud. This requires a key pair. You should be prompted to choose an existing key pair or create one. If you do not have an existing one, choose “Create a new key pair”, then download it! . . Getting your web app in the cloud . At this point, your EC2 instance is being built and configured. You can follow its progress back in the AWS console. Once you see a green “running” icon next to your instance, you are able to toggle it, then click the “Connect” button near the top of the console. Follow AWS’s instructions (shown below) to ssh into the instance from your local terminal. . . After sshing into the instance, there are a few options to get our code into the cloud. This tutorial will assume your code is in a public github repository, however, if necessary, you can scp your code directly from your local computer to your instance. For our purposes, we’ll use git clone . ubuntu@ip-172-31-10-244:~$ git clone https://github.com/collinprather/streamlit-docker.git . Now that our code is on the instance, we can use the 2 commands featured in part 1 to build, then run the image. . $ cd streamlit-docker/ $ docker image build -t streamlit:app . $ docker container run -p 8501:8501 -d streamlit:app . Now, the web app will be served at &lt;EC2 public IP address&gt;:8501! The public IP address can be found under “IPv4 Public IP” in the AWS console. Once you’ve located it, pull open a web browser and verify that your app is running as expected! . . When you&#39;re done, don&#39;t forget to terminate your instance!",
            "url": "https://collinprather.github.io/blog/docker/aws/2020/03/11/streamlit-docker-pt2.html",
            "relUrl": "/docker/aws/2020/03/11/streamlit-docker-pt2.html",
            "date": " • Mar 11, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Deploying web apps with Streamlit, Docker, and AWS - part 1",
            "content": "Containerizing a Streamlit web app with Docker . In this tutorial, we will be assuming that you already have a streamlit app ready to deploy. If you don’t, no worries! The streamlit docs have some great tutorials, but if you’d rather jump right in, you can go ahead and git clone my small example here. . So let’s say that you’ve got your streamlit web app prepared in a directory that looks as follows: . ├── app.py # streamlit code ├── content.py # textual content - imported into app ├── images # various images for your app │   ├── logo.png │   ├── background.png ├── requirements.txt # libraries used by your app . In order to containerize this application with Docker, the first step will be to add a Dockerfile to the root of your directory. Your Dockerfile acts as a set of instructions (more specifically, a set of commands that could equivalently be called from the command line) from which Docker will build an image for your app. Using this image, Docker will then create a container. If this is all new, I’d recommend taking a look at this Docker overview! . The Dockerfile . The Dockerfile for my small example looks like this: . # base image # a little overkill but need it to install dot cli for dtreeviz FROM ubuntu:18.04 # ubuntu installing - python, pip, graphviz RUN apt-get update &amp;&amp; apt-get install python3.7 -y &amp;&amp; apt-get install python3-pip -y &amp;&amp; apt-get install graphviz -y # exposing default port for streamlit EXPOSE 8501 # making directory of app WORKDIR /streamlit-docker # copy over requirements COPY requirements.txt ./requirements.txt # install pip then packages RUN pip3 install -r requirements.txt # copying all files over COPY . . # cmd to launch app when container is run CMD streamlit run app.py # streamlit-specific commands for config ENV LC_ALL=C.UTF-8 ENV LANG=C.UTF-8 RUN mkdir -p /root/.streamlit RUN bash -c &#39;echo -e &quot; [general] n email = &quot; &quot; n &quot; &gt; /root/.streamlit/credentials.toml&#39; RUN bash -c &#39;echo -e &quot; [server] n enableCORS = false n &quot; &gt; /root/.streamlit/config.toml&#39; . . The `ubuntu` portions are a bit overkill! It is worth mentioning that the ubuntu portions of this Dockerfile are a little bit overkill for the scale of this small web app, however, I found them necessary to get a nice rendering of an svg file generated by the dtreeviz package. This is also a great example of a simpler Dockerfile on this blog. There is a lot to unpack here, so I’ll do so line by line. . Ubuntu commands . At the top, we build off the base ubuntu image with the following line: . FROM ubuntu:18.04 . This means that docker pulls the ubuntu:18.04 image from dockerhub to begin with. . Next, we update and install a few things we’ll need for our web app. . RUN apt-get update &amp;&amp; apt-get install python3.7 -y &amp;&amp; apt-get install python3-pip -y &amp;&amp; apt-get install graphviz -y . Setting up the app . After that, we set up our actual application within the image. Since streamlit’s default port is 8501, we open up that port. . EXPOSE 8501 . From there, we (optionally) define a working directory within the image and copy over all of our files, then install the necessary python libraries (as defined in our requirements.txt) . WORKDIR /streamlit-docker COPY requirements.txt ./requirements.txt RUN pip3 install -r requirements.txt COPY . . . . It is typically not recommended to copy all files to the image the way we&#39;ve done above (particularly if you have large files). However, since this is a small example, it won&#39;t cause any issues for us. Streamlit-specific commands . Finally, we must include a few commands to ensure that streamlist runs as expected. We define a command to launch our web app whenever our docker container gets launched, . CMD streamlit run app.py . and we finish by including a few commands to configure streamlit correctly. . ENV LC_ALL=C.UTF-8 ENV LANG=C.UTF-8 RUN mkdir -p /root/.streamlit RUN bash -c &#39;echo -e &quot; [general] n email = &quot; &quot; n &quot; &gt; /root/.streamlit/credentials.toml&#39; RUN bash -c &#39;echo -e &quot; [server] n enableCORS = false n &quot; &gt; /root/.streamlit/config.toml&#39; . Building the docker image and running the container . Now that we have our web app and our Dockerfile all set up, we’re ready to build the image. We can do so with a single command. . docker image build -t streamlit:app . . . Note: you must run this command from the same directory as your Dockerfile where -t tags our image as streamlit:app and . references the directory with the Dockerfile. When you run from the command line, you will see Docker moving through each step defined in the Dockerfile and installing many packages to the image. Once it is finished (it may take a few minutes the first time), you should see a verification like Successfully tagged streamlit:app, letting you know that the Docker image was successfully created. You can further verify that the image was created correctly by running docker image ls, where you should see something like . $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE streamlit app ecda3493de33 50 seconds ago 1.52GB . At this point, our image has been successfully built and we are ready to run it by way of container! (If the differences between an image and container are confusing, this short post provides some helpful distinctions). One command will do the trick, . docker container run -p 8501:8501 -d streamlit:app . where -p allows you to publish a container’s port to the host’s port and -d allows you to run it in the background. You can then verify that is is running with a command like this, . $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 82ecab4abfb1 streamlit:app &quot;/bin/sh -c &#39;streaml…&quot; 22 seconds ago Up 21 seconds 0.0.0.0:8501-&gt;8501/tcp weird_name . Better yet, pop open a web browser and you can view your web app, running in a docker container, at http://localhost:8501/. If you’re using my example, it should look something like this! . .",
            "url": "https://collinprather.github.io/blog/docker/aws/2020/03/10/streamlit-docker-pt1.html",
            "relUrl": "/docker/aws/2020/03/10/streamlit-docker-pt1.html",
            "date": " • Mar 10, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Eigendecomposition and SVD for Deep Learning",
            "content": "I’ve been reading through Goodfellow’s Deep Learning Book, which starts with a review of the applied mathematics and machine learning basics necessary to understand deep learning. While reading through the linear algebra chapter, I realized that I had become a bit rusty working with eigenvalues and matrix decomposition, so I’ve decided to explain them here! It’s been a great exercise to review these topics myself and I hope that you find them helpful as well. . Eigendecomposition . We are often concerned with breaking mathematical objects down into smaller pieces in order to gain a better understanding of its characteristics. A classic example of this is decomposing an integer into its prime factors. For example, $60=2^2 times 3 times 5$, which tells us that 60 is divisible by 4, but not by 8 - not necessarily obvious just by looking at the number 60. In the same way, we can decompose matrices into different representations that give us some quick insight to its structure. A common form of matrix decomposition is called eigenvalue decomposition. Before we get too far, let’s define exactly what eigenvectors and eigenvalues are. . An eigenvector of a square matrix $ mathbf{A}$ is a nonzero vector $ mathbf{v}$ such that multipication by $ mathbf{A}$ alters only the scale of $ mathbf{v}$: . Av=λv mathbf{A} mathbf{v}= lambda mathbf{v}Av=λv . The scalar $ lambda$ is known as the eigenvalue corresponding to the eigenvector. . Finding eigenvalues . With a bit of algebraic manipulation, we can see that . Av=λvAv−λv=0(A−λI)v=0 begin{aligned} mathbf{A} mathbf{v}&amp;= lambda mathbf{v} mathbf{A} mathbf{v}- lambda mathbf{v}&amp;=0 left( mathbf{A}- lambda I right) mathbf{v}&amp;=0 end{aligned}AvAv−λv(A−λI)v​=λv=0=0​ . This form of the equation is useful to us because it is known that if a matrix is non-invertible, then the determinant of that matrix must equal zero. Hence, if we solve the equation . det⁡(A−λI)=0 det left( mathbf{A}- lambda I right)=0det(A−λI)=0 . (this is called the characteristic equation) for $ lambda$, then we will find all eigenvalues which satisfy $ left( mathbf{A}- lambda I right) mathbf{v}=0$. Solving this equation can sometimes be tricky, requiring polynomial long-division in order to do so by hand. . Deriving the eigendecomposition matrix . We can decompose the matrix $ mathbf{A}$ into its eigenvalues and eigenvectors with the following equation: . A=Vdiag(λ)V−1 mathbf{A}= mathbf{V} text{diag($ lambda$)} mathbf{V}^{-1}A=Vdiag(λ)V−1 . Now we will show how we can derive this equation. Suppose that we have an $k times k$ matrix $ mathbf{A}$ with eigenvectors $ mathbf{v}_1, mathbf{v}_2, dots, mathbf{v}_k$, and corresponding eigenvalues $ lambda_1, lambda_2, dots, lambda_k$. We define the matrix $ mathbf{V}$ by concatenating all of our eigenvectors into a matrix like so: . V=[v1v2…vk]=[v1,1v2,1…vk1v1,2v2,2…vk,2⋮⋮⋱⋮v1,k……vk,k] begin{aligned} mathbf{V}&amp;= left[ begin{matrix} mathbf{v}_1&amp; mathbf{v}_2&amp; dots&amp; mathbf{v}_k end{matrix} right] &amp;= left[ begin{matrix} v_{1,1}&amp; v_{2,1}&amp; dots &amp; v_{k_1} v_{1,2}&amp; v_{2,2}&amp; dots&amp; v_{k,2} vdots&amp; vdots&amp; ddots&amp; vdots v_{1,k}&amp; dots&amp; dots&amp; v_{k,k} end{matrix} right] end{aligned}V​=[v1​​v2​​…​vk​​]=⎣⎢⎢⎢⎢⎡​v1,1​v1,2​⋮v1,k​​v2,1​v2,2​⋮…​……⋱…​vk1​​vk,2​⋮vk,k​​⎦⎥⎥⎥⎥⎤​​ . We now define the $k times k$ matrix $ text{diag($ lambda$)}$ as . diag(λ)=[λ10…00λ2…0⋮⋮⋱⋮0……λk] begin{aligned} text{diag($ lambda$)}&amp;= left[ begin{matrix} lambda_1&amp;0&amp; dots &amp; 0 0&amp; lambda_2&amp; dots&amp; 0 vdots&amp; vdots&amp; ddots&amp; vdots 0&amp; dots&amp; dots&amp; lambda_k end{matrix} right] end{aligned}diag(λ)​=⎣⎢⎢⎢⎢⎡​λ1​0⋮0​0λ2​⋮…​……⋱…​00⋮λk​​⎦⎥⎥⎥⎥⎤​​ . With all of these pieces, we can see how to decompose the matrix. . AV=[Av1Av2…Avk]AV=[λ1v1λ2v2…λkvk]AV=[λ1v1,1λ2v2,1…λkvk1λ1v1,2λ2v2,2…λkvk,2⋮⋮⋱⋮λ1v1,k……λkvk,k]AV=[v1,1v2,1…vk1v1,2v2,2…vk,2⋮⋮⋱⋮v1,k……vk,k][λ10…00λ2…0⋮⋮⋱⋮0……λk]AV=Vdiag(λ)A=Vdiag(λ)V−1 begin{aligned} mathbf{A} mathbf{V}&amp;= left[ begin{matrix} mathbf{A} mathbf{v}_1&amp; mathbf{A} mathbf{v}_2&amp; dots&amp; mathbf{A} mathbf{v}_k end{matrix} right] mathbf{A} mathbf{V}&amp;= left[ begin{matrix} lambda_1 mathbf{v}_1&amp; lambda_2 mathbf{v}_2&amp; dots&amp; lambda_k mathbf{v}_k end{matrix} right] mathbf{A} mathbf{V}&amp;= left[ begin{matrix} lambda_1v_{1,1}&amp; lambda_2 v_{2,1}&amp; dots &amp; lambda_k v_{k_1} lambda_1v_{1,2}&amp; lambda_2v_{2,2}&amp; dots&amp; lambda_k v_{k,2} vdots&amp; vdots&amp; ddots&amp; vdots lambda_1 v_{1,k}&amp; dots&amp; dots&amp; lambda_k v_{k,k} end{matrix} right] mathbf{A} mathbf{V}&amp;= left[ begin{matrix} v_{1,1}&amp; v_{2,1}&amp; dots &amp; v_{k_1} v_{1,2}&amp; v_{2,2}&amp; dots&amp; v_{k,2} vdots&amp; vdots&amp; ddots&amp; vdots v_{1,k}&amp; dots&amp; dots&amp; v_{k,k} end{matrix} right] left[ begin{matrix} lambda_1&amp;0&amp; dots &amp; 0 0&amp; lambda_2&amp; dots&amp; 0 vdots&amp; vdots&amp; ddots&amp; vdots 0&amp; dots&amp; dots&amp; lambda_k end{matrix} right] mathbf{A} mathbf{V}&amp;= mathbf{V} text{diag($ lambda$)} mathbf{A}&amp;= mathbf{V} text{diag($ lambda$)} mathbf{V}^{-1} end{aligned}AVAVAVAVAVA​=[Av1​​Av2​​…​Avk​​]=[λ1​v1​​λ2​v2​​…​λk​vk​​]=⎣⎢⎢⎢⎢⎡​λ1​v1,1​λ1​v1,2​⋮λ1​v1,k​​λ2​v2,1​λ2​v2,2​⋮…​……⋱…​λk​vk1​​λk​vk,2​⋮λk​vk,k​​⎦⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎡​v1,1​v1,2​⋮v1,k​​v2,1​v2,2​⋮…​……⋱…​vk1​​vk,2​⋮vk,k​​⎦⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎡​λ1​0⋮0​0λ2​⋮…​……⋱…​00⋮λk​​⎦⎥⎥⎥⎥⎤​=Vdiag(λ)=Vdiag(λ)V−1​ . This decomposition allows us to analyze certain properties of the matrix. For example, we can conclude that the matrix is singular if and only if any of the eigenvalues are zero. The benefits of this kind of decomposition, however, are limited. The glaring issue is that the eigendecomposition of a matrix is only defined if the matrix is square. For this reason, in practice, we usually resort to singular value decomposition instead, which is defined on all real matrices and gives us the same kind of information about the matrix. . Resources . In the coming months, I hope to learn more about the applications of matrix decomposition in the context of Deep Learning. My understanding is that we often desire to decompose weights matrices associated with neural networks to analyze how a model is learning. This paper delineates the usefulness of SVD in practice. Additionally, Charles Martin writes on the analysis of weights matrix eigenvalues in this accessible article. Finally, if you are looking for a different perspective matrix decomposition, I recommend hadrienj’s series of articles on linear algebra for Deep Learning which follow along with Goodfellow’s book. .",
            "url": "https://collinprather.github.io/blog/linear%20algebra/2018/12/31/evd-svd.html",
            "relUrl": "/linear%20algebra/2018/12/31/evd-svd.html",
            "date": " • Dec 31, 2018"
        }
        
    
  
    
        ,"post4": {
            "title": "Logistic Regression and MLE",
            "content": "When traditionally using logistic regression to perform binary classification of a dataset, we make predictions, $ hat{y}$ about the class of each data point by . y^=σ(wTx+b), hat{y}= sigma(w^Tx+b),y^​=σ(wTx+b), . where $ sigma(z)= frac{1}{1+e^{-z}}$. We interpret our prediction $ hat{y}$ as the probability that the given data point is from class 1. Mathematically, $ hat{y}=p(y=1|x)$. . if $y=1$: $p(y|x)= hat{y}$ | if $y=0$: $p(y|x)=1- hat{y}$ | . We can shrink all of this math into a succint one-liner as follows: . p(y∣x)=y^y(1−y^)1−yp(y|x)= hat{y}^y(1- hat{y})^{1-y}p(y∣x)=y^​y(1−y^​)1−y . Since the log function is monotonically increasing, we can be sure that taking the log of each side of this equation holds the equality. Taking the log of each side, we see that, . log⁡(p(y∣x))=log⁡(y^y(1−y^)1−y)=ylog⁡(y^)+(1−y)log⁡(1−y^) begin{aligned} log(p(y|x))&amp;= log( hat{y}^y(1- hat{y})^{1-y}) &amp;= y log( hat{y}) + (1-y) log(1- hat{y}) end{aligned}log(p(y∣x))​=log(y^​y(1−y^​)1−y)=ylog(y^​)+(1−y)log(1−y^​)​ . If the algebra here was confusing, check out the exponent rules. Interestingly, this is precisely the log loss function that is used in logistic regression. . Under the assumption that our data points are identically, independently distributed (iid), then minimizing the log loss function over the entire data set is equivalent to performing maximum likelihood estimation of the parameters. . log p(y)=log∏i=1mp(y(i)∣x(i))log p(y)=log prod_{i=1}^{m}p(y^{(i)}|x^{(i)})log p(y)=logi=1∏m​p(y(i)∣x(i)) . Since the log of a product is equal to the sum of logs, . log⁡ p(y)=∑i=1mlog⁡ p(y(i)∣x(i))=∑i=1my(i)log⁡(y^(i))+(1−y(i))log⁡(1−y^(i))as shown above begin{aligned} log p(y) &amp;= sum_{i=1}^{m} log p(y^{(i)}|x^{(i)}) &amp;= sum_{i=1}^{m} y^{(i)} log( hat{y}^{(i)}) + (1-y^{(i)}) log(1- hat{y}^{(i)})&amp;&amp; text{as shown above} end{aligned}log p(y)​=i=1∑m​log p(y(i)∣x(i))=i=1∑m​y(i)log(y^​(i))+(1−y(i))log(1−y^​(i))​​as shown above​ . If you are familiar with machine learning, you’ll notice that this is the same as the typical logistic regression cost function, which is usually represented as so . J(w,b)=−1m∑i=1m[y(i)log⁡(y^(i)+(1−y(i))log⁡(1−y^(i))] begin{aligned} J(w,b)&amp;=- frac{1}{m} sum_{i=1}^{m} left[ y^{(i)} log( hat{y}^{(i)} + (1-y^{(i)}) log(1- hat{y}^{(i)}) right] end{aligned}J(w,b)​=−m1​i=1∑m​[y(i)log(y^​(i)+(1−y(i))log(1−y^​(i))]​ . Thus, we’ve shown that using gradient descent to identify the parameters that minimize the cost function is mathematically equivalent to performing a maximum-likelihood estimation of the parameters! .",
            "url": "https://collinprather.github.io/blog/statistics/2018/12/24/logistic-regression-and-MLE.html",
            "relUrl": "/statistics/2018/12/24/logistic-regression-and-MLE.html",
            "date": " • Dec 24, 2018"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "My name is Collin Prather and I am currently a Masters of Data Science student at the University of San Francisco. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://collinprather.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "Featured Projects",
          "content": "Anomaly Detection with AWS Inference Pipeline . . DrivenData Turbidity Competition . . Grand Rapids Car Crash Analysis . .",
          "url": "https://collinprather.github.io/blog/featured/",
          "relUrl": "/featured/",
          "date": ""
      }
      
  

  

  
      ,"page4": {
          "title": "Presentations/Talks",
          "content": "Machine Learning from Scratch . September 2018, 40 mins, at the Big Data Ignite Conference . I had a blast speaking at the Big Data Ignite 2018 conference. This talk dove into the math that powers machine learning. . . Deep learning for baseball card classification . April 2019, 40 mins, at Cornerstone University . . Using transfer learning to teach Keras’ MobileNetV2 to differentiate between Red Sox and Yankees baseball cards. I affectionately named the model “BambinoNet”, after the Great Bambino. . . MoneyBall is Dead . Feb 2020, 15 mins, at Standard Deviant . . For SF’s Beer Week 2020, I gave a talk titled, “MoneyBall is Dead: Why Player Development is the Final Frontier for Baseball Analytics”. This included a high-level overview of what data analysis in MLB organizations has looked like since the turn of the century and why the adoption of new high-frequency data collection devices, like high-speed cameras and radar, is changing how the game of baseball is played. . . Machine Learning Overview . February 2019, 60 mins, at SpinDance . A wide overview of the field of Machine Learning. Intended to leave you fluent enough in machine learning concepts and lingo to develop some intuition into what problems could be solved using machine learning, where it could be integrated into our current projects, and give you some direction if you decide that you’d like to learn more. . . Machine Learning for Developers . May 2019, 60 mins, at SpinDance . A technical talk walking through the steps in the ML pipeline and how developers can integrate and deploy ML solutions into their applications .",
          "url": "https://collinprather.github.io/blog/presentations/",
          "relUrl": "/presentations/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

}